\set VERBOSITY terse
SET search_path = 'public';
CREATE EXTENSION pg_pathman;
CREATE SCHEMA test_update_triggers;
create table test_update_triggers.test (val int not null);
select create_hash_partitions('test_update_triggers.test', 'val', 2,
							  partition_names := array[
								'test_update_triggers.test_1',
								'test_update_triggers.test_2']);
 create_hash_partitions 
------------------------
                      2
(1 row)

create or replace function test_update_triggers.test_trigger() returns trigger as $$
begin
	raise notice '%', format('%s %s %s (%s)', TG_WHEN, TG_OP, TG_LEVEL, TG_TABLE_NAME);

	if TG_OP::text = 'DELETE'::text then
		return old;
	else
		return new;
	end if; end;
$$ language plpgsql;
create trigger bu before update ON test_update_triggers.test_1
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger bd before delete ON test_update_triggers.test_1
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger bi before insert ON test_update_triggers.test_1
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger au after update ON test_update_triggers.test_1
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger ad after delete ON test_update_triggers.test_1
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger ai after insert ON test_update_triggers.test_1
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger bu before update ON test_update_triggers.test_2
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger bd before delete ON test_update_triggers.test_2
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger bi before insert ON test_update_triggers.test_2
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger au after update ON test_update_triggers.test_2
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger ad after delete ON test_update_triggers.test_2
	for each row execute procedure test_update_triggers.test_trigger ();
create trigger ai after insert ON test_update_triggers.test_2
	for each row execute procedure test_update_triggers.test_trigger ();
insert into test_update_triggers.test values (1);
NOTICE:  BEFORE INSERT ROW (test_1)
NOTICE:  AFTER INSERT ROW (test_1)
set pg_pathman.enable_partitionrouter = t;
update test_update_triggers.test set val = val + 1 returning *, tableoid::regclass;
NOTICE:  BEFORE UPDATE ROW (test_1)
NOTICE:  AFTER UPDATE ROW (test_1)
 val |          tableoid           
-----+-----------------------------
   2 | test_update_triggers.test_1
(1 row)

update test_update_triggers.test set val = val + 1 returning *, tableoid::regclass;
NOTICE:  BEFORE UPDATE ROW (test_1)
NOTICE:  BEFORE DELETE ROW (test_1)
NOTICE:  BEFORE INSERT ROW (test_2)
NOTICE:  AFTER DELETE ROW (test_1)
NOTICE:  AFTER INSERT ROW (test_2)
 val |          tableoid           
-----+-----------------------------
   3 | test_update_triggers.test_2
(1 row)

update test_update_triggers.test set val = val + 1 returning *, tableoid::regclass;
NOTICE:  BEFORE UPDATE ROW (test_2)
NOTICE:  AFTER UPDATE ROW (test_2)
 val |          tableoid           
-----+-----------------------------
   4 | test_update_triggers.test_2
(1 row)

update test_update_triggers.test set val = val + 1 returning *, tableoid::regclass;
NOTICE:  BEFORE UPDATE ROW (test_2)
NOTICE:  BEFORE DELETE ROW (test_2)
NOTICE:  BEFORE INSERT ROW (test_1)
NOTICE:  AFTER DELETE ROW (test_2)
NOTICE:  AFTER INSERT ROW (test_1)
 val |          tableoid           
-----+-----------------------------
   5 | test_update_triggers.test_1
(1 row)

update test_update_triggers.test set val = val + 1 returning *, tableoid::regclass;
NOTICE:  BEFORE UPDATE ROW (test_1)
NOTICE:  AFTER UPDATE ROW (test_1)
 val |          tableoid           
-----+-----------------------------
   6 | test_update_triggers.test_1
(1 row)

DROP SCHEMA test_update_triggers CASCADE;
NOTICE:  drop cascades to 4 other objects
DROP EXTENSION pg_pathman CASCADE;
